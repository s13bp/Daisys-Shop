{"ast":null,"code":"/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\nexport function defer() {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n\n  return {\n    promise,\n    resolve,\n    reject\n  };\n} // TODO use bip32-path library\n\nexport function splitPath(path) {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n} // TODO use async await\n\nexport function eachSeries(arr, fun) {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\nexport function foreach(arr, callback) {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else return callback(array[index], index).then(function (res) {\n      result.push(res);\n      return iterate(index + 1, array, result);\n    });\n  }\n\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\nexport function doIf(condition, callback) {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\nexport function asyncWhile(predicate, callback) {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n\n  return Promise.resolve([]).then(iterate);\n}","map":{"version":3,"mappings":"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","names":["defer","resolve","reject","promise","Promise","success","failure","splitPath","path","result","components","split","forEach","element","number","parseInt","isNaN","length","push","eachSeries","arr","fun","reduce","p","e","then","foreach","callback","iterate","index","array","res","doIf","condition","asyncWhile","predicate"],"sources":["../src/utils.js"],"sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: T => void,\n  reject: any => void\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function(success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: A => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function(res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n"]},"metadata":{},"sourceType":"module"}