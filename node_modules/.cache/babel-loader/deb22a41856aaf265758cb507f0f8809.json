{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommentEncryptionUtils = exports.decryptComment = exports.encryptComment = exports.decryptData = exports.encryptData = void 0;\n\nvar crypto_1 = require(\"crypto\");\n\nvar dataEncryptionKey_1 = require(\"./dataEncryptionKey\");\n\nvar ecies_1 = require(\"./ecies\");\n\nvar ECIES_SESSION_KEY_LEN = 129;\nvar MIN_COMMENT_KEY_LENGTH = 33;\nvar TAG = 'CommentEncryption';\n/**\n * Encrypts a buffer to two recipients. Throws on error.\n *\n * @param {Buffer} data Data to encrypt\n * @param {Buffer} pubKeyRecipient Public key of the recipient. Uncompressed without leading 0x04.\n * @param {Buffer} pubKeySelf Public key of the sender. Uncompressed without leading 0x04.\n * @returns {Buffer} Encrypted data to sender and recipient.\n */\n\nfunction encryptData(data, pubKeyRecipient, pubKeySelf) {\n  var sessionKey = (0, crypto_1.randomBytes)(16);\n  var sessionKeyToSelf = (0, ecies_1.Encrypt)(pubKeySelf, sessionKey);\n  var sessionKeyToOther = (0, ecies_1.Encrypt)(pubKeyRecipient, sessionKey);\n  var ciphertext = (0, ecies_1.AES128EncryptAndHMAC)(sessionKey, sessionKey, data);\n  return Buffer.concat([sessionKeyToOther, sessionKeyToSelf, ciphertext]);\n}\n\nexports.encryptData = encryptData;\n/**\n * Decrypts raw data that was encrypted by encryptData. Throws on error.\n *\n * @param {Buffer} data Data to decrypt.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {Buffer} Decrypted data.\n */\n\nfunction decryptData(data, key, sender) {\n  // Deal with presumably enencrypted comments\n  if (data.length < ECIES_SESSION_KEY_LEN * 2 + 48) {\n    throw new Error('Buffer length too short');\n  }\n\n  var sessionKeyEncrypted = sender ? data.slice(ECIES_SESSION_KEY_LEN, ECIES_SESSION_KEY_LEN * 2) : data.slice(0, ECIES_SESSION_KEY_LEN);\n  var sessionKey = (0, ecies_1.Decrypt)(key, sessionKeyEncrypted);\n  var encryptedMessage = data.slice(ECIES_SESSION_KEY_LEN * 2);\n  return (0, ecies_1.AES128DecryptAndHMAC)(sessionKey, sessionKey, encryptedMessage);\n}\n\nexports.decryptData = decryptData;\n/**\n * Encrypts a comment. If it can encrypt, it returns a base64 string with the following:\n *    ECIES(session key to other) + ECIES(session key to self) + AES(comment)\n * If it fails to encrypt, it returns the comment without any changes.\n *\n * @param {string} comment Comment to encrypt.\n * @param {Buffer} pubKeyRecipient Public key of the recipient. May be compressed.\n * @param {Buffer} pubKeySelf Public key of the sender. May be compressed.\n * @returns {string} base64 string of encrypted comment if can encrypt, otherwise comment.\n */\n\nfunction encryptComment(comment, pubKeyRecipient, pubKeySelf) {\n  try {\n    if (pubKeyRecipient.length < MIN_COMMENT_KEY_LENGTH || pubKeySelf.length < MIN_COMMENT_KEY_LENGTH) {\n      throw new Error('Comment key too short');\n    } // Uncompress public keys & strip out the leading 0x04\n\n\n    var pubRecip = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeyRecipient);\n    var pubSelf = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeySelf);\n    var data = encryptData(Buffer.from(comment, 'ucs2'), pubRecip, pubSelf).toString('base64');\n    return {\n      success: true,\n      comment: data\n    };\n  } catch (e) {\n    console.info(TAG + \"/Error encrypting comment: \" + e);\n    return {\n      success: false,\n      comment: comment\n    };\n  }\n}\n\nexports.encryptComment = encryptComment;\n/**\n * Decrypts a comments encrypted by encryptComment. If it cannot decrypt the comment (i.e. comment was\n * never encrypted in the first place), it returns the comments without any changes.\n *\n * @param {string} comment Comment to decrypt. If encrypted, base64 encoded. May be plaintext.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {string} Decrypted comment if can decrypt, otherwise comment.\n */\n\nfunction decryptComment(comment, key, sender) {\n  try {\n    var buf = Buffer.from(comment, 'base64');\n    var data = decryptData(buf, key, sender).toString('ucs2');\n    return {\n      success: true,\n      comment: data\n    };\n  } catch (error) {\n    console.info(TAG + \"/Could not decrypt: \" + error.message);\n    return {\n      success: false,\n      comment: comment\n    };\n  }\n}\n\nexports.decryptComment = decryptComment;\nexports.CommentEncryptionUtils = {\n  encryptComment: encryptComment,\n  decryptComment: decryptComment\n};","map":{"version":3,"mappings":"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","names":["ECIES_SESSION_KEY_LEN","MIN_COMMENT_KEY_LENGTH","TAG","encryptData","data","pubKeyRecipient","pubKeySelf","sessionKey","sessionKeyToSelf","sessionKeyToOther","ciphertext","Buffer","concat","exports","decryptData","key","sender","length","Error","sessionKeyEncrypted","slice","encryptedMessage","encryptComment","comment","pubRecip","pubSelf","from","toString","success","e","console","info","decryptComment","buf","error","message"],"sourceRoot":"","sources":["../src/commentEncryption.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}