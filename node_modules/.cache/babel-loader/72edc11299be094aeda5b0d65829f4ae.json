{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapAddressListDataOnto = exports.mapAddressListOnto = exports.findAddressIndex = exports.NULL_ADDRESS = exports.bufferToHex = exports.hexToBuffer = exports.isHexString = exports.getAddressChunks = exports.ensureLeading0x = exports.trimLeading0x = exports.normalizeAddressWith0x = exports.isNullAddress = exports.normalizeAddress = exports.eqAddress = void 0;\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\n\nvar eqAddress = function eqAddress(a, b) {\n  return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(b);\n};\n\nexports.eqAddress = eqAddress;\n\nvar normalizeAddress = function normalizeAddress(a) {\n  return (0, exports.trimLeading0x)(a).toLowerCase();\n};\n\nexports.normalizeAddress = normalizeAddress;\n\nvar isNullAddress = function isNullAddress(a) {\n  return (0, exports.normalizeAddress)(a) === exports.NULL_ADDRESS;\n};\n\nexports.isNullAddress = isNullAddress;\n\nvar normalizeAddressWith0x = function normalizeAddressWith0x(a) {\n  return (0, exports.ensureLeading0x)(a).toLowerCase();\n};\n\nexports.normalizeAddressWith0x = normalizeAddressWith0x;\n\nvar trimLeading0x = function trimLeading0x(input) {\n  return input.startsWith('0x') ? input.slice(2) : input;\n};\n\nexports.trimLeading0x = trimLeading0x;\n\nvar ensureLeading0x = function ensureLeading0x(input) {\n  return input.startsWith('0x') ? input : \"0x\" + input;\n};\n\nexports.ensureLeading0x = ensureLeading0x; // Turns '0xce10ce10ce10ce10ce10ce10ce10ce10ce10ce10'\n// into ['ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10']\n\nvar getAddressChunks = function getAddressChunks(input) {\n  return (0, exports.trimLeading0x)(input).match(/.{1,4}/g) || [];\n};\n\nexports.getAddressChunks = getAddressChunks;\n\nvar isHexString = function isHexString(input) {\n  return HEX_REGEX.test(input);\n};\n\nexports.isHexString = isHexString;\n\nvar hexToBuffer = function hexToBuffer(input) {\n  return Buffer.from((0, exports.trimLeading0x)(input), 'hex');\n};\n\nexports.hexToBuffer = hexToBuffer;\n\nvar bufferToHex = function bufferToHex(buf) {\n  return (0, exports.ensureLeading0x)(buf.toString('hex'));\n};\n\nexports.bufferToHex = bufferToHex;\nexports.NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\nvar findAddressIndex = function findAddressIndex(address, addresses) {\n  return addresses.findIndex(function (x) {\n    return (0, exports.eqAddress)(x, address);\n  });\n};\n\nexports.findAddressIndex = findAddressIndex; // Returns an array of indices mapping the entries of oldAddress[] to newAddress[]\n\nvar mapAddressListOnto = function mapAddressListOnto(oldAddress, newAddress) {\n  var oldAddressIndex = oldAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  var newAddressIndex = newAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  oldAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n  newAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n\n  var res = __spreadArray([], Array(oldAddress.length).fill(-1), true);\n\n  for (var i = 0, j = 0; i < oldAddress.length && j < newAddress.length;) {\n    var cmp = oldAddressIndex[i].address.localeCompare(newAddressIndex[j].address);\n\n    if (cmp < 0) {\n      i++;\n    } else if (cmp > 0) {\n      j++;\n    } else {\n      // Address is present in both lists\n      res[oldAddressIndex[i].index] = newAddressIndex[j].index;\n      i++;\n      j++;\n    }\n  }\n\n  return res;\n};\n\nexports.mapAddressListOnto = mapAddressListOnto; // Returns data[] reordered by mapAddressListOnto(), and initiaValue for any entry of\n// oldAddress[] not present in newAddress[].\n\nfunction mapAddressListDataOnto(data, oldAddress, newAddress, initialValue) {\n  var res = __spreadArray([], Array(oldAddress.length).fill(initialValue), true);\n\n  if (data.length === 0) {\n    return res;\n  }\n\n  var addressIndexMap = (0, exports.mapAddressListOnto)(oldAddress, newAddress);\n\n  for (var i = 0; i < addressIndexMap.length; i++) {\n    if (addressIndexMap[i] >= 0) {\n      res[addressIndexMap[i]] = data[i];\n    }\n  }\n\n  return res;\n}\n\nexports.mapAddressListDataOnto = mapAddressListDataOnto;","map":{"version":3,"mappings":"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","names":["HEX_REGEX","eqAddress","a","b","exports","normalizeAddress","toLowerCase","isNullAddress","normalizeAddressWith0x","trimLeading0x","input","startsWith","slice","ensureLeading0x","getAddressChunks","match","isHexString","test","hexToBuffer","from","bufferToHex","buf","toString","findAddressIndex","address","addresses","findIndex","x","mapAddressListOnto","oldAddress","newAddress","oldAddressIndex","map","index","newAddressIndex","sort","localeCompare","res","Array","length","fill","i","j","cmp","mapAddressListDataOnto","data","initialValue","addressIndexMap"],"sourceRoot":"","sources":["../src/address.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}