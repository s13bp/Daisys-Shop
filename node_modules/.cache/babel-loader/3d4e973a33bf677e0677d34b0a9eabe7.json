{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _errors = require(\"@ledgerhq/errors\");\n\nvar Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  var b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nvar initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nvar createHIDframing = function createHIDframing(channel, packetSize) {\n  return {\n    makeBlocks: function makeBlocks(apdu) {\n      var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      var blockSize = packetSize - 5;\n      var nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, // fill data with padding\n      Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      var blocks = [];\n\n      for (var i = 0; i < nbBlocks; i++) {\n        var head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        var chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n    reduceResponse: function reduceResponse(acc, chunk) {\n      var _ref = acc || initialAcc,\n          data = _ref.data,\n          dataLength = _ref.dataLength,\n          sequence = _ref.sequence;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new _errors.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new _errors.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new _errors.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      var chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data: data,\n        dataLength: dataLength,\n        sequence: sequence\n      };\n    },\n    getReducedResult: function getReducedResult(acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\n\nvar _default = createHIDframing;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt16BE","TransportError","readUInt8","chunkData","getReducedResult"],"sources":["../src/hid-framing.js"],"sourcesContent":["// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"]},"metadata":{},"sourceType":"script"}