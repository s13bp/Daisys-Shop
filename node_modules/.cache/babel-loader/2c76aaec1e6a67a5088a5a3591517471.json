{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(_ref => {\n      let {\n        alternates\n      } = _ref;\n      return alternates.some(a => a.interfaceClass === 255);\n    });\n\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n    }\n\n    const interfaceNumber = iface.interfaceNumber;\n\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n\n    const transport = new TransportWebUSB(device, interfaceNumber);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    }; // $FlowFixMe\n\n\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};\n\nasync function gracefullyResetDevice(device) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}","map":{"version":3,"mappings":"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","names":["Transport","hidFraming","identifyUSBProductId","log","TransportOpenUserCancelled","TransportInterfaceNotAvailable","TransportWebUSBGestureRequired","DisconnectedDeviceDuringOperation","DisconnectedDevice","getLedgerDevices","getFirstLedgerDevice","requestLedgerDevice","isSupported","configurationValue","endpointNumber","TransportWebUSB","constructor","device","interfaceNumber","deviceModel","channel","Math","floor","random","packetSize","_disconnectEmitted","_emitDisconnect","e","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","length","transferOut","result","acc","getReducedResult","r","transferIn","buffer","Buffer","from","data","reduceResponse","catch","message","includes","productId","request","open","openConnected","devices","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","find","alternates","some","a","interfaceClass","claimInterface","close","transport","onDisconnect","navigator","usb","removeEventListener","addEventListener","exchangeBusyPromise","releaseInterface","setScrambleKey","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","error","window","DOMException","code","unsubscribe","reset","err","console","warn"],"sources":["../src/TransportWebUSB.js"],"sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}