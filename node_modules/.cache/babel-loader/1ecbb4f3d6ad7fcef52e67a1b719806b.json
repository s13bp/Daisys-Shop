{"ast":null,"code":"var Bytes = require(\"./bytes\");\n\nvar inis = \"pbtdkgxjfvlrmnsz\".split(\"\");\nvar mids = \"auie\".split(\"\");\nvar back = [inis, mids].map(function (chars) {\n  var map = {};\n\n  for (var i = 0; i < chars.length; ++i) {\n    map[chars[i]] = i;\n  }\n\n  return map;\n});\n\nvar syllableFromB64 = function syllableFromB64(b64) {\n  var ini = b64 >>> 2 & 15;\n  var mid = b64 >>> 0 & 3;\n  return inis[ini] + mids[mid];\n};\n\nvar syllableToB64 = function syllableToB64(syllable) {\n  var ini = back[0][syllable[0]];\n  var mid = back[1][syllable[1]];\n  return ini * 4 + mid;\n};\n\nvar b64sFromBytes = function b64sFromBytes(bytes) {\n  //BoooooBoooooBoooooBooooo\n  //BoooooooBoooooooBooooooo\n  var b64s = [],\n      b64;\n\n  for (var i = 0, l = Math.ceil(bytes.length * 8 / 6); i < l; ++i) {\n    var j = i / 8 * 6 | 0;\n    b64s.push(i % 4 === 0 ? bytes[j + 0] / 4 | 0 : i % 4 === 1 ? bytes[j + 0] % 4 * 16 + (bytes[j + 1] / 16 | 0) : i % 4 === 2 ? bytes[j + 0] % 16 * 4 + (bytes[j + 1] / 64 | 0) : bytes[j + 0] % 64 * 1);\n  }\n\n  return b64s;\n};\n\nvar b64sToBytes = function b64sToBytes(b64s) {\n  var bytes = [];\n\n  for (var i = 0, l = Math.floor(b64s.length * 6 / 8); i < l; ++i) {\n    var j = i / 6 * 8 | 0;\n    bytes.push(i % 3 === 0 ? b64s[j + 0] % 64 * 4 + (b64s[j + 1] / 16 | 0) : i % 3 === 1 ? b64s[j + 0] % 16 * 16 + (b64s[j + 1] / 4 | 0) : b64s[j + 0] % 4 * 64 + (b64s[j + 1] / 1 | 0));\n  }\n\n  return bytes;\n};\n\nvar fromBytes = function fromBytes(bytes) {\n  return b64sFromBytes(Bytes.toArray(bytes)).map(syllableFromB64).join(\"\");\n};\n\nvar toBytes = function toBytes(syllables) {\n  return Bytes.fromArray(b64sToBytes(syllables.match(/\\w\\w/g).map(syllableToB64)));\n};\n\nmodule.exports = {\n  fromBytes: fromBytes,\n  toBytes: toBytes\n};","map":{"version":3,"sources":["/Users/crypto/Daisys/node_modules/eth-lib/lib/desubits.js"],"names":["Bytes","require","inis","split","mids","back","map","chars","i","length","syllableFromB64","b64","ini","mid","syllableToB64","syllable","b64sFromBytes","bytes","b64s","l","Math","ceil","j","push","b64sToBytes","floor","fromBytes","toArray","join","toBytes","syllables","fromArray","match","module","exports"],"mappings":"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","sourcesContent":["const Bytes = require(\"./bytes\");\n\nconst inis = \"pbtdkgxjfvlrmnsz\".split(\"\");\n\nconst mids = \"auie\".split(\"\");\n\nconst back = [inis, mids].map(chars => {\n  let map = {};\n  for (let i = 0; i < chars.length; ++i) map[chars[i]] = i;\n  return map;\n});\n\nconst syllableFromB64 = b64 => {\n  const ini = b64 >>> 2 & 15;\n  const mid = b64 >>> 0 & 3;\n  return inis[ini] + mids[mid];\n};\n\nconst syllableToB64 = syllable => {\n  const ini = back[0][syllable[0]];\n  const mid = back[1][syllable[1]];\n  return ini * 4 + mid;\n};\n\nconst b64sFromBytes = bytes => {\n  //BoooooBoooooBoooooBooooo\n  //BoooooooBoooooooBooooooo\n  let b64s = [],\n      b64;\n  for (let i = 0, l = Math.ceil(bytes.length * 8 / 6); i < l; ++i) {\n    let j = i / 8 * 6 | 0;\n    b64s.push(i % 4 === 0 ? bytes[j + 0] / 4 | 0 : i % 4 === 1 ? bytes[j + 0] % 4 * 16 + (bytes[j + 1] / 16 | 0) : i % 4 === 2 ? bytes[j + 0] % 16 * 4 + (bytes[j + 1] / 64 | 0) : bytes[j + 0] % 64 * 1);\n  }\n  return b64s;\n};\n\nconst b64sToBytes = b64s => {\n  let bytes = [];\n  for (let i = 0, l = Math.floor(b64s.length * 6 / 8); i < l; ++i) {\n    let j = i / 6 * 8 | 0;\n    bytes.push(i % 3 === 0 ? b64s[j + 0] % 64 * 4 + (b64s[j + 1] / 16 | 0) : i % 3 === 1 ? b64s[j + 0] % 16 * 16 + (b64s[j + 1] / 4 | 0) : b64s[j + 0] % 4 * 64 + (b64s[j + 1] / 1 | 0));\n  }\n  return bytes;\n};\n\nconst fromBytes = bytes => b64sFromBytes(Bytes.toArray(bytes)).map(syllableFromB64).join(\"\");\n\nconst toBytes = syllables => Bytes.fromArray(b64sToBytes(syllables.match(/\\w\\w/g).map(syllableToB64)));\n\nmodule.exports = {\n  fromBytes,\n  toBytes\n};"]},"metadata":{},"sourceType":"script"}