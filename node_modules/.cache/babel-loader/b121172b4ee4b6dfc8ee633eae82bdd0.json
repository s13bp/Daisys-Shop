{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useContractKitMethods = void 0;\n\nvar react_1 = require(\"react\");\n\nvar react_device_detect_1 = require(\"react-device-detect\");\n\nvar connectors_1 = require(\"./connectors\");\n\nvar constants_1 = require(\"./constants\");\n\nfunction useContractKitMethods(_a, dispatch) {\n  var _this = this;\n\n  var connector = _a.connector,\n      networks = _a.networks,\n      network = _a.network;\n  var destroy = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , connector.close()];\n\n          case 1:\n            _a.sent();\n\n            dispatch('destroy');\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, connector]);\n  var initConnector = (0, react_1.useCallback)(function (nextConnector) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var initialisedConnector_1, netId_1, newNetwork, e_1, error;\n\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , nextConnector.initialise()];\n\n          case 1:\n            initialisedConnector_1 = _c.sent();\n            dispatch('initialisedConnector', initialisedConnector_1);\n            return [4\n            /*yield*/\n            , initialisedConnector_1.kit.web3.eth.net.getId()];\n\n          case 2:\n            netId_1 = _c.sent();\n            newNetwork = networks.find(function (n) {\n              return netId_1 === n.chainId;\n            });\n\n            if (newNetwork !== network) {\n              dispatch('setNetwork', network);\n            } // This happens if the network changes on the wallet side\n            // and we need to update what network we're storing\n            // accordingly.\n\n\n            (_a = initialisedConnector_1.onNetworkChange) === null || _a === void 0 ? void 0 : _a.call(initialisedConnector_1, function (chainId) {\n              var network = networks.find(function (n) {\n                return n.chainId === chainId;\n              });\n              if (netId_1 === chainId || !network) return; // TODO: We should probably throw an error if we can't find the new chainId\n\n              if (network) {\n                dispatch('setNetwork', network);\n                initialisedConnector_1.updateKitWithNetwork && initialisedConnector_1.updateKitWithNetwork(network).then(function () {\n                  dispatch('initialisedConnector', initialisedConnector_1);\n                }).catch(function (e) {\n                  console.error('[use-contractkit] Error switching network', nextConnector.type, e);\n                  var error = e instanceof Error ? e : new Error(\"Failed to initialise connector with \".concat(network.name));\n                  dispatch('setConnectorInitError', error);\n                  throw e;\n                });\n              }\n            });\n            (_b = initialisedConnector_1.onAddressChange) === null || _b === void 0 ? void 0 : _b.call(initialisedConnector_1, function (address) {\n              dispatch('setAddress', address);\n            });\n            return [2\n            /*return*/\n            , initialisedConnector_1];\n\n          case 3:\n            e_1 = _c.sent();\n            console.error('[use-contractkit] Error initializing connector', nextConnector.type, e_1);\n            error = e_1 instanceof Error ? e_1 : new Error('Failed to initialise connector');\n            dispatch('setConnectorInitError', error);\n            throw e_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, network, networks]); // This is just to be used to for users to explicitly change\n  // the network. It doesn't work for all wallets.\n\n  var updateNetwork = (0, react_1.useCallback)(function (newNetwork) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var connectorArgs, ConnectorConstructor, newConnector;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (constants_1.STATIC_NETWORK_WALLETS.includes(connector.type)) {\n              throw new Error(\"The connected wallet's network must be changed from the wallet.\");\n            }\n\n            if (network === newNetwork) return [2\n            /*return*/\n            ];\n            if (!connector.initialised) return [3\n            /*break*/\n            , 3];\n            connectorArgs = JSON.parse(localStorage.getItem(constants_1.localStorageKeys.lastUsedWalletArguments) || '[]');\n            return [4\n            /*yield*/\n            , connector.close()];\n\n          case 1:\n            _a.sent();\n\n            ConnectorConstructor = connectors_1.CONNECTOR_TYPES[connector.type];\n            newConnector = new (ConnectorConstructor.bind.apply(ConnectorConstructor, __spreadArray([void 0, newNetwork], __read(connectorArgs), false)))();\n            return [4\n            /*yield*/\n            , initConnector(newConnector)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            dispatch('setNetwork', newNetwork);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, connector, network, initConnector]);\n  var connect = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var connectionResultPromise, newConnector;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectionResultPromise = new Promise(function (resolve) {\n              dispatch('setConnectionCallback', resolve);\n            });\n            return [4\n            /*yield*/\n            , connectionResultPromise];\n\n          case 1:\n            newConnector = _a.sent();\n            dispatch('setConnectionCallback', null);\n\n            if (newConnector === false) {\n              throw new Error('Connection cancelled');\n            }\n\n            return [2\n            /*return*/\n            , newConnector];\n        }\n      });\n    });\n  }, [dispatch]);\n  var getConnectedKit = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var initialisedConnection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            initialisedConnection = connector;\n            if (!(connector.type === constants_1.WalletTypes.Unauthenticated)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , connect()];\n\n          case 1:\n            initialisedConnection = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!!initialisedConnection.initialised) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , initConnector(initialisedConnection)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , initialisedConnection.kit];\n        }\n      });\n    });\n  }, [connect, connector, initConnector]);\n  var updateFeeCurrency = (0, react_1.useCallback)(function (newFeeCurrency) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , connector.updateFeeCurrency(newFeeCurrency)];\n\n          case 1:\n            _a.sent();\n\n            dispatch('setFeeCurrency', newFeeCurrency);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [connector, dispatch]);\n  var performActions = (0, react_1.useCallback)(function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    return __awaiter(_this, void 0, void 0, function () {\n      var kit, results, operations_1, operations_1_1, op, _a, _b, e_2, e_3_1;\n\n      var e_3, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getConnectedKit()];\n\n          case 1:\n            kit = _d.sent();\n            dispatch('setPendingActionCount', operations.length);\n            results = [];\n            _d.label = 2;\n\n          case 2:\n            _d.trys.push([2, 10, 11, 12]);\n\n            operations_1 = __values(operations), operations_1_1 = operations_1.next();\n            _d.label = 3;\n\n          case 3:\n            if (!!operations_1_1.done) return [3\n            /*break*/\n            , 9];\n            op = operations_1_1.value;\n            _d.label = 4;\n\n          case 4:\n            _d.trys.push([4, 6,, 7]); // When on mobile direct user to their wallet app.\n\n\n            if (react_device_detect_1.isMobile && connector.getDeeplinkUrl) {\n              window.open(connector.getDeeplinkUrl(''), '_blank');\n            }\n\n            _b = (_a = results).push;\n            return [4\n            /*yield*/\n            , op(kit)];\n\n          case 5:\n            _b.apply(_a, [_d.sent()]);\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            e_2 = _d.sent();\n            dispatch('setPendingActionCount', 0);\n            throw e_2;\n\n          case 7:\n            dispatch('decrementPendingActionCount');\n            _d.label = 8;\n\n          case 8:\n            operations_1_1 = operations_1.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_3_1 = _d.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (operations_1_1 && !operations_1_1.done && (_c = operations_1.return)) _c.call(operations_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            return [2\n            /*return*/\n            , results];\n        }\n      });\n    });\n  }, [getConnectedKit, dispatch, react_device_detect_1.isMobile]);\n  return {\n    destroy: destroy,\n    initConnector: initConnector,\n    updateNetwork: updateNetwork,\n    connect: connect,\n    getConnectedKit: getConnectedKit,\n    performActions: performActions,\n    updateFeeCurrency: updateFeeCurrency\n  };\n}\n\nexports.useContractKitMethods = useContractKitMethods;","map":{"version":3,"mappings":"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","names":["useContractKitMethods","_a","dispatch","connector","networks","network","destroy","close","initConnector","nextConnector","initialise","initialisedConnector_1","_c","kit","web3","eth","net","getId","netId_1","newNetwork","find","n","chainId","onNetworkChange","updateKitWithNetwork","then","catch","e","console","error","type","Error","name","onAddressChange","_b","address","e_1","updateNetwork","constants_1","includes","initialised","connectorArgs","JSON","parse","localStorage","getItem","lastUsedWalletArguments","ConnectorConstructor","connectors_1","newConnector","apply","__spreadArray","__read","connect","connectionResultPromise","Promise","resolve","getConnectedKit","initialisedConnection","Unauthenticated","updateFeeCurrency","newFeeCurrency","performActions","operations","_d","length","results","operations_1","operations_1_1","op","react_device_detect_1","getDeeplinkUrl","window","open","push","e_2","exports"],"sourceRoot":"","sources":["../src/use-contract-kit-methods.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}